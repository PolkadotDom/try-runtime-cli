searchState.loadedDescShard("libp2p_core", 0, "Transports, upgrades, multiplexing and node handling of …\nA public Ed25519 key.\nRepresentation of a Multiaddr.\nPerform IP address translation.\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nMulti-address re-export.\nMuxing is the process of splitting a connection into …\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nConnection-oriented communication channels.\nContains everything related to upgrading a connection or a …\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nThe endpoint roles associated with an established …\nThe socket comes from a dialer.\nWe dialed the node.\nThe endpoint roles associated with a peer-to-peer …\nThe socket comes from a listener.\nWe received the node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address of the remote stored in this struct.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this endpoint a dialer?\nReturns true if we are <code>Dialer</code>.\nIs this endpoint a listener?\nReturns true if we are <code>Listener</code>.\nReturns true if the connection is relayed.\nModifies the address of the remote stored in this struct.\nTurns the <code>ConnectedPoint</code> into the corresponding <code>Endpoint</code>.\nMultiaddress that was successfully dialed.\nLocal connection address.\nWhether the role of the local node on the connection …\nAddress used to send back data to the remote.\nImplements <code>Future</code> and dispatches all method calls to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn Ed25519 keypair.\nA public Ed25519 key.\nIdentity keypair of a node.\nThe public key of a node’s identity keypair.\nEncode the public key into a protobuf structure for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode a private key from a protobuf structure and parse …\nDecode a public key from a protobuf structure, e.g. read …\nGenerate a new Ed25519 keypair.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key of this keypair.\nSign a message using the private key of this keypair, …\nConvert the <code>PublicKey</code> into the corresponding <code>PeerId</code>.\nEncode a private key as protobuf structure.\nEncode the public key into a protobuf structure for …\nDecode a public key from a protobuf structure, e.g. read …\nVerify a signature for a message using this public key, …\nAn Ed25519 keypair.\nAn Ed25519 public key.\nAn Ed25519 secret key.\nDecode a keypair from the binary format produced by …\nDecode a public key from a byte array as produced by …\nEncode the keypair into a byte array by concatenating the …\nEncode the public key into a byte array in compressed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an Ed25519 secret key from a byte slice, zeroing …\nGenerate a new random Ed25519 keypair.\nGenerate a new Ed25519 secret key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key of this keypair.\nGet the secret key of this keypair.\nSign a message using the private key of this keypair.\nConvert the keypair into a byte array by concatenating the …\nConvert the public key to a byte array in compressed form, …\nTry to parse a keypair from the binary format produced by …\nTry to parse a public key from a byte array containing the …\nTry to parse an Ed25519 secret key from a byte slice …\nVerify the Ed25519 signature on a message using the public …\nAn error during decoding of key material.\nAn error during signing of a message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe address of the remote has changed.\nError type of the muxer\nImplementation of <code>StreamMuxer</code> that allows only one …\nProvides multiplexing for a connection by allowing users …\nAbstract <code>StreamMuxer</code>.\nAn event produced by a <code>StreamMuxer</code>.\nExtension trait for <code>StreamMuxer</code>.\nType of the object that represents the raw substream where …\nAbstract type for asynchronous reading and writing.\nReturns a future for closing this <code>StreamMuxer</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurns a stream muxer into a <code>StreamMuxerBox</code>.\nConstruct a new <code>SubstreamBox</code> from something that …\nCreates a new <code>SingletonMuxer</code>.\nPoll to allow the underlying connection to make progress.\nPoll to close this <code>StreamMuxer</code>.\nConvenience function for calling <code>StreamMuxer::poll_close</code> …\nPoll for new inbound substreams.\nConvenience function for calling <code>StreamMuxer::poll_inbound</code> …\nPoll for a new, outbound substream.\nConvenience function for calling <code>StreamMuxer::poll_outbound</code>…\nConvenience function for calling <code>StreamMuxer::poll</code> for …\nFailed to extract the payload from the envelope.\nFailed to decode a multi-address.\nFailed to decode the peer ID.\nFailed to decode the provided bytes as a <code>PeerRecord</code>.\nThe signer of the envelope is different than the peer id …\nRepresents a peer routing record.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to re-construct a <code>PeerRecord</code> from a <code>SignedEnvelope</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>PeerRecord</code> by authenticating the provided …\nErrors that occur whilst decoding a <code>SignedEnvelope</code> from …\nDecoding the provided bytes as a signed envelope failed.\nThe public key in the envelope could not be converted to …\nThe signature on the signed envelope does not verify with …\nThe public key in the envelope could not be converted to …\nErrors that occur whilst extracting the payload of a …\nA signed envelope contains an arbitrary byte string …\nThe payload contained in the envelope is not of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode a <code>SignedEnvelope</code> using the protobuf encoding …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode this <code>SignedEnvelope</code> using the protobuf encoding …\nConstructs a new <code>SignedEnvelope</code>.\nExtract the payload and signing key of this <code>SignedEnvelope</code>.\nVerify this <code>SignedEnvelope</code> against the provided …\nAn address is no longer being listened on.\nA <code>Boxed</code> transport is a <code>Transport</code> whose <code>Dial</code>, <code>Listener</code> and …\nA pending <code>Output</code> for an outbound connection, obtained from …\nAn error that occurred during connection setup.\nA connection is incoming on one of the listeners.\nA listener closed.\nA listener errored.\nThe ID of a single listener.\nA pending <code>Output</code> for an inbound connection, obtained from …\nThe <code>Multiaddr</code> passed as parameter is not supported.\nA new address is being listened on.\nTransport that is possibly disabled.\nAny other error that a <code>Transport</code> may produce.\nThe result of a connection setup process, including …\nA transport provides connection-oriented communication …\nAn error during dialing or listening on a <code>Transport</code>.\nEvent produced by <code>Transport</code>s.\nPerforms a transport-specific mapping of an address …\nApplies a function producing an asynchronous result to …\nBoxes the transport, including custom transport errors.\nDials the given <code>Multiaddr</code>, returning a future for a …\nAs <code>Transport::dial</code> but has the local node act as a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to turn this transport event into the expire <code>Multiaddr</code>.\nTry to turn this transport event into the upgrade parts of …\nTry to turn this transport event into the listener error.\nTry to turn this transport event into the new <code>Multiaddr</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::AddressExpired</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::ListenerError</code> …\nReturns <code>true</code> if this is a <code>TransportEvent::NewAddress</code>.\nReturns <code>true</code> if this is an <code>Incoming</code> transport event.\nListens on the given <code>Multiaddr</code> for inbound connections.\nApplies a function on the connections created by the …\nApplies a function to the the error in …\nApplies a function on the errors generated by the futures …\nIn case this <code>TransportEvent</code> is an <code>ListenerError</code>, or …\nIn case this <code>TransportEvent</code> is an upgrade, apply the given …\nCreates a new <code>ListenerId</code>.\nBuilds a disabled <code>OptionalTransport</code>.\nAdds a fallback transport that is used when encountering …\nPoll for <code>TransportEvent</code>s.\nRemove a listener.\nBuilds an <code>OptionalTransport</code> with the given transport in an …\nTransports with timeouts on the connection setup.\nConfiguration of transport protocol upgrades.\nBegins a series of protocol upgrades via an …\nThe error value.\nThe new address that is being listened on.\nThe new address that is being listened on.\nThe listener that is listening on the new address.\nThe listener that is no longer listening on the address.\nThe listener that produced the upgrade.\nThe ID of the listener that closed.\nThe ID of the listener that errored.\nLocal connection address.\nReason for the closure. Contains <code>Ok(())</code> if the stream …\nAddress used to send back data to the incoming client.\nThe produced upgrade.\nSee the <code>Transport::and_then</code> method.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStruct returned by <code>or_transport()</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nImplementation of <code>AsyncRead</code> and <code>AsyncWrite</code>. Not meant to …\nImplementation of <code>Transport</code> that doesn’t support any …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a new <code>DummyTransport</code>.\nSee <code>Transport::map</code>.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee <code>Transport::map_err</code>.\nDialing future for <code>MapErr</code>.\nListening upgrade future for <code>MapErr</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTries to listen on a port that is already in use.\nA channel represents an established, in-memory, logical …\nA channel represents an established, in-memory, logical …\nConnection to a <code>MemoryTransport</code> currently being opened.\nListener for memory connections.\nTransport that supports <code>/memory/N</code> multiaddresses.\nError that can be produced from the <code>MemoryTransport</code>.\nThere’s no listener on the given port.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOther kind of error.\nWraps around a <code>Future</code>. Turns the error type from …\nThe transport timed out.\nAn error happened in the timer.\nA <code>TransportTimeout</code> is a <code>Transport</code> that wraps another …\nError that can be produced by the <code>TransportTimeout</code> layer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps around a <code>Transport</code> to add timeouts to all the …\nWraps around a <code>Transport</code> to add timeouts to the ingoing …\nWraps around a <code>Transport</code> to add timeouts to the outgoing …\nAn upgrade that authenticates the remote peer, typically …\nAn transport with peer authentication, obtained from …\nA <code>Builder</code> facilitates upgrading of a <code>Transport</code> for use with\nThe <code>Transport::Dial</code> future of an <code>Upgrade</code>d transport.\nThe <code>Transport::ListenerUpgrade</code> future of an <code>Upgrade</code>d …\nAn upgrade that negotiates a (sub)stream multiplexer on …\nA authenticated and multiplexed transport, obtained from …\nError in the transport.\nErrors produced by a transport upgrade.\nA custom upgrade on an <code>Authenticated</code> transport.\nError while upgrading to a protocol.\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nApplies an arbitrary upgrade.\nUpgrades the transport to perform authentication of the …\nBoxes the authenticated, multiplexed transport, including …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a timeout to the setup and protocol upgrade process …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpgrades the transport with a (sub)stream multiplexer.\nLike <code>Authenticated::multiplex</code> but accepts a function which …\nCreates a <code>Builder</code> over the given (base) <code>Transport</code>.\nAdds a timeout to the setup and protocol upgrade process …\nAdds a timeout to the setup and protocol upgrade process …\nError during the post-negotiation handshake.\nDummy implementation of <code>UpgradeInfo</code>/<code>InboundUpgrade</code>/…\nPossible error during the handshake.\nPossible error during the handshake.\nProtocol negotiation failed because no protocol could be …\nImplements the <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nPossible upgrade on an inbound connection or substream.\nFuture returned by <code>apply_inbound</code>. Drives the upgrade …\nExtension trait for <code>InboundUpgrade</code>. Automatically …\nOpaque type representing a negotiable protocol.\nIterator returned by <code>protocol_info</code>.\nReceived an invalid message from the remote.\nA protocol (name) is invalid.\nI/O error.\nWraps around an upgrade and applies a closure to the …\nWraps around an upgrade and applies a closure to the error.\nWraps around an upgrade and applies a closure to the …\nWraps around an upgrade and applies a closure to the error.\nA <code>Future</code> that waits on the completion of protocol …\nError that can happen when negotiating a protocol with the …\nUpgrade that can be disabled at runtime.\nPossible upgrade on an outbound connection or substream.\nFuture returned by <code>apply_outbound</code>. Drives the upgrade …\nExtention trait for <code>OutboundUpgrade</code>. Automatically …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nA protocol error.\nA protocol error occurred during the negotiation.\nTypes serving as protocol names.\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nError during the negotiation process.\nUpgrade that combines two upgrades into one. Supports all …\nToo many protocols have been returned by the remote.\nError that can happen when upgrading a connection or …\nCommon trait for upgrades that can be applied on inbound …\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nApplies an upgrade to the inbound and outbound direction …\nTries to perform an upgrade on an inbound connection or …\nTries to perform an upgrade on an outbound connection or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a new <code>FromFnUpgrade</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a new object that wraps around <code>Self</code> and applies a …\nReturns a new object that wraps around <code>Self</code> and applies a …\nReturns a new object that wraps around <code>Self</code> and applies a …\nReturns a new object that wraps around <code>Self</code> and applies a …\nCombines two upgrades into an <code>SelectUpgrade</code>.\nCreates a disabled <code>OptionalUpgrade</code>.\nReturns the list of protocols that are supported. Used …\nThe protocol name as bytes. Transmitted on the network.\nReads a length-prefixed message from the given socket.\nReads a variable-length integer from the <code>socket</code>.\nCreates an enabled <code>OptionalUpgrade</code>.\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nWrites a message to the given socket with a length prefix …\nWrites a variable-length integer to the <code>socket</code>.")